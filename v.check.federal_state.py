#!/usr/bin/env python3
#
############################################################################
#
# MODULE:      v.check.federal_state
# AUTHOR(S):   Lina Krisztian

# PURPOSE:     Checks in which German federal state an area of interest is
#              located
# COPYRIGHT:   (C) 2022 by mundialis GmbH & Co. KG and the GRASS Development
#              Team
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
#############################################################################

# %Module
# % description: Checks in which German federal state an area of interest is located.
# % keyword: vector
# % keyword: import
# % keyword: federal state
# % keyword: administrative boundaries
# % keyword: open-geodata-germany
# %end

# %option G_OPT_V_INPUT
# % key: aoi
# % required: yes
# % description: Area of interest (vector map in GRASS DB) to check federal state for.
# %end

# %option G_OPT_V_INPUT
# % key: federal_states
# % required: no
# % description: Federal states as vector map in GRASS DB. Can be generated by running module once with output option.
# %end

# %option G_OPT_V_OUTPUT
# % key: output
# % required: no
# % description: Name for output vector map of federal state boundaries (if saving desired)
# %end

# %option G_OPT_F_OUTPUT
# % key: federal_state_file
# % required: no
# % description: The path for the output file for saving federal states overlapping with the AOI
# %end

# %flag
# % key: g
# % description: Print the stats in shell script style
# %end

# %rules
# % exclusive: federal_states, output, -g
# %end

import atexit
import os

import grass.script as grass

from grass_gis_helpers.cleanup import general_cleanup
from grass_gis_helpers.open_geodata_germany.federal_state import (
    FS_ABBREVIATION,
    import_administrative_boundaries,
)


rm_vectors = []
path_to_zipfile = None
# PID for unambiguous layer naming
PID = f"{grass.tempname(8)}_{os.getpid()}"


def cleanup():
    # remove unzipped federal state data in tempdir-folder
    rm_dirs = []
    if path_to_zipfile:
        rm_dirs.append(path_to_zipfile)

    general_cleanup(rm_vectors=rm_vectors, rm_dirs=rm_dirs)


def get_federal_state_in_aoi(
    area, federal_state_invect, federal_state_outvect, save_file_path=None
):
    """Get for federal state of given polygon"""
    rm_vectors.append(federal_state_outvect)
    grass.run_command(
        "v.select",
        ainput=federal_state_invect,
        binput=area,
        output=federal_state_outvect,
        operator="intersects",
        quiet=True,
    )
    check_overlay_map = list(
        grass.parse_command("g.list", type="vec", pattern="overlay*").keys()
    )
    if check_overlay_map:
        fd_overlay = list(
            grass.parse_command(
                "v.db.select",
                map=federal_state_outvect,
                columns="GEN",
                flags="c",
            ).keys()
        )
        grass.message(", ".join(fd_overlay))
        fs_abb = [FS_ABBREVIATION[fs] for fs in fd_overlay]
        # save optional
        if save_file_path:
            try:
                f = open(save_file_path, mode="w")
                f.write(",".join(fd_overlay))
                f.close()
            except FileNotFoundError:
                grass.warning(
                    "Could not save output as file. "
                    "No valid filepath given."
                )
        elif flags["g"]:
            print(f"FEDERAL_STATE={','.join(fd_overlay)}")
            print(f"FS={','.join(fs_abb)}")
    else:
        grass.warning("Not in Germany")


def main():
    global rm_vectors
    global path_to_zipfile

    area = options["aoi"]
    input_fs = options["federal_states"]
    output_vec_map = options["output"]
    save_file_path = options["federal_state_file"]
    if not output_vec_map:
        output_vec_map_name = f"states_{PID}"
        rm_vectors.append(output_vec_map_name)
    else:
        output_vec_map_name = output_vec_map
    output_vec_map_fds = f"overlay_{PID}"

    """ get federal state boundary data """
    if input_fs:
        # if federal states already as input given
        output_vec_map_name = input_fs
        pass
    else:
        import_administrative_boundaries(
            output_vec_map_name, aoi=area, level="LAN"
        )

    """ check for correct federal_state input (if given)
    """
    if (
        not grass.find_file(name=output_vec_map_name, element="vector")["file"]
        or grass.parse_command("v.info", map=output_vec_map_name, flags="t")[
            "centroids"
        ]
        == 0
    ):
        print("Not in Germany")
    elif "GEN" not in grass.vector_columns(output_vec_map_name):
        grass.fatal(
            "Stopped v.check.federal_state: "
            "The given federal state input has not the right format. "
            "Try another vector map or generate the right formatted "
            "input with the optional option 'output'."
        )
    else:
        get_federal_state_in_aoi(
            area, output_vec_map_name, output_vec_map_fds, save_file_path
        )


if __name__ == "__main__":
    options, flags = grass.parser()
    atexit.register(cleanup)
    main()
